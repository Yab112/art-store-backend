generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                    String    @id @default(uuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Session {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model TwoFactor {
  id          String   @id
  userId      String
  secret      String
  backupCodes String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Verification {
  id         String   @id @default(uuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Category {
  id          String              @id @default(uuid())
  name        String              @unique
  description String?
  slug        String              @unique
  image       String? // MinIO/S3 URL for background image
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  artworks    ArtworkOnCategory[]
}

model ArtworkOnCategory {
  id         String @id @default(uuid())
  artworkId  String
  categoryId String

  artwork  Artwork  @relation(fields: [artworkId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([artworkId, categoryId])
}

model Chat {
  id                       String      @id
  requestId                String?
  status                   CHAT_STATUS @default(OPEN)
  createdAt                DateTime    @default(now())
  updatedAt                DateTime
  clientId                 String
  taskerId                 String
  User_Chat_clientIdToUser User        @relation("Chat_clientIdToUser", fields: [clientId], references: [id])
  User_Chat_taskerIdToUser User        @relation("Chat_taskerIdToUser", fields: [taskerId], references: [id])
  Message                  Message[]
}

model Dispute {
  id           String         @id
  artworkId    String?
  targetUserId String?
  raisedById   String
  assignedToId String?
  reason       String
  description  String?
  resolution   String?
  status       DISPUTE_STATUS @default(IN_PROGRESS)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime

  // Relations
  artwork                         Artwork? @relation(fields: [artworkId], references: [id], onDelete: Cascade)
  targetUser                      User?    @relation("Dispute_targetUser", fields: [targetUserId], references: [id])
  User_Dispute_assignedToIdToUser User?    @relation("Dispute_assignedToIdToUser", fields: [assignedToId], references: [id], onDelete: Cascade)
  User_Dispute_raisedByIdToUser   User     @relation("Dispute_raisedByIdToUser", fields: [raisedById], references: [id], onDelete: Cascade)
}

model Message {
  id                            String         @id
  chatId                        String
  senderId                      String
  type                          MESSAGE_TYPE
  content                       String
  status                        MESSAGE_STATUS @default(SENT)
  createdAt                     DateTime       @default(now())
  receiverId                    String
  Chat                          Chat           @relation(fields: [chatId], references: [id], onDelete: Cascade)
  User_Message_receiverIdToUser User           @relation("Message_receiverIdToUser", fields: [receiverId], references: [id])
  User_Message_senderIdToUser   User           @relation("Message_senderIdToUser", fields: [senderId], references: [id])
}

model Notification {
  id        String            @id
  userId    String
  type      NOTIFICATION_TYPE
  message   String
  read      Boolean           @default(false)
  entityId  String
  createdAt DateTime          @default(now())
  User      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Payment {
  id        String         @id
  bookingId String
  amount    Float
  method    String
  status    PAYMENT_STATUS @default(PENDING)
  createdAt DateTime       @default(now())
}

model Review {
  id        String   @id
  artworkId String
  userId    String
  rating    Int
  comment   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Artwork   Artwork  @relation(fields: [artworkId], references: [id], onDelete: Cascade)
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                                 String         @id @default(uuid())
  name                               String
  email                              String         @unique
  emailVerified                      Boolean        @default(false)
  image                              String?
  coverImage                         String?
  bio                                String?        // Artist biography/introduction
  location                           String?        // Artist location/country
  website                            String?        // Artist website URL
  emailSubscription                  Boolean        @default(true) // Subscribe to blog post notifications
  score                              Float          @default(0)
  role                               String
  banned                             Boolean        @default(false)
  banReason                          String?
  banExpires                         DateTime?
  twoFactorEnabled                   Boolean        @default(false)
  createdAt                          DateTime       @default(now())
  updatedAt                          DateTime
  firstlogin                         Boolean?
  // Analytics & Engagement
  lastActiveAt                       DateTime?
  profileViews                       Int            @default(0)
  heatScore                          Float          @default(0)
  // Preferences & Settings
  themePreference                    String         @default("light")
  languagePreference                  String         @default("en")
  timezone                           String?        @default("UTC")
  messagingPreferences               Json?
  // Talent Types (many-to-many)
  talentTypes                        UserOnTalentType[]
  accounts                           Account[]
  Chat_Chat_clientIdToUser           Chat[]         @relation("Chat_clientIdToUser")
  Chat_Chat_taskerIdToUser           Chat[]         @relation("Chat_taskerIdToUser")
  Dispute_Dispute_assignedToIdToUser Dispute[]      @relation("Dispute_assignedToIdToUser")
  Dispute_Dispute_raisedByIdToUser   Dispute[]      @relation("Dispute_raisedByIdToUser")
  disputesAgainstUser                Dispute[]      @relation("Dispute_targetUser")
  reportsFiled                       Report[]       @relation("Report_reporter")
  reportsResolved                    Report[]       @relation("Report_resolvedBy")
  Message_Message_receiverIdToUser   Message[]      @relation("Message_receiverIdToUser")
  Message_Message_senderIdToUser     Message[]      @relation("Message_senderIdToUser")
  Notification                       Notification[]
  sessions                           Session[]
  twoFactors                         TwoFactor[]
  artworks                           Artwork[]
  reviews                            Review[]
  collections                        Collection[]   @relation("Collection_createdBy")
  interactions                       Interaction[]  @relation("Interaction_user")
  favorites                          Favorite[]
  cartItems                          CartItem[]
  withdrawals                        Withdrawal[]
  blogPosts                          BlogPost[]     @relation("BlogPost_author")
  blogComments                       BlogComment[]  @relation("BlogComment_user")
  blogVotes                          BlogVote[]     @relation("BlogVote_user")
  blogShares                         BlogShare[]    @relation("BlogShare_user")
  orders                             Order[]        @relation("Order_buyer")
  sellerTransactions                 Transaction[]   @relation("SellerTransaction")

  // Earnings from selling artwork
  earning                            Decimal        @default(0) @db.Decimal(10,2)

  @@map("users")
}

model Artwork {
  id                     String        @id @default(uuid())
  title                  String?
  artist                 String
  support                String
  state                  String
  yearOfArtwork          String
  dimensions             Json // {height, width, depth}
  isFramed               Boolean
  weight                 String
  handDeliveryAccepted   Boolean
  origin                 String
  yearOfAcquisition      String?
  description            String?
  desiredPrice           Float
  acceptPriceNegotiation Boolean
  accountHolder          String
  iban                   String
  bicCode                String?
  acceptTermsOfSale      Boolean
  giveSalesMandate       Boolean
  proofOfOrigin          String? // MinIO URL
  photos                 String[] // Array of MinIO URLs
  status                 ArtworkStatus @default(PENDING)
  isApproved             Boolean       @default(false)
  createdAt              DateTime      @default(now())
  updatedAt              DateTime      @updatedAt
  userId                 String
  user                   User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  reviews              Review[]
  // Relations added by new models
  collectionOnArtworks CollectionOnArtwork[]
  orderItems           OrderItem[]
  interactions         Interaction[]
  comments             Comment[]
  featuredContents     FeaturedContent[]
  disputes             Dispute[]
  favorites            Favorite[]
  cartItems            CartItem[]
  categories           ArtworkOnCategory[]

  @@map("artworks")
}

model Collection {
  id          String   @id @default(uuid())
  name        String
  description String?
  coverImage  String?
  visibility  String   @default("private")
  createdAt   DateTime @default(now())
  createdBy   String

  // Relations
  user     User                  @relation("Collection_createdBy", fields: [createdBy], references: [id], onDelete: Cascade)
  artworks CollectionOnArtwork[]
}

model CollectionOnArtwork {
  id           String @id @default(uuid())
  collectionId String
  artworkId    String

  collection Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  artwork    Artwork    @relation(fields: [artworkId], references: [id], onDelete: Cascade)

  @@unique([collectionId, artworkId])
}

model Favorite {
  id        String   @id @default(uuid())
  userId    String
  artworkId String
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  artwork Artwork @relation(fields: [artworkId], references: [id], onDelete: Cascade)

  @@unique([userId, artworkId])
  @@map("favorites")
}

model CartItem {
  id        String   @id @default(uuid())
  userId    String
  artworkId String
  quantity  Int      @default(1)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  artwork Artwork @relation(fields: [artworkId], references: [id], onDelete: Cascade)

  @@unique([userId, artworkId])
  @@map("cart_items")
}

model Order {
  id          String      @id @default(uuid())
  buyerEmail  String
  userId      String? // User who created the order (authenticated user)
  totalAmount Decimal     @db.Decimal(10, 2)
  status      OrderStatus @default(PENDING)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  user          User?         @relation("Order_buyer", fields: [userId], references: [id], onDelete: SetNull)
  items         OrderItem[]
  transaction   Transaction?
  receipt       Receipt?
  platformEarning PlatformEarning?

  @@index([userId])
  @@index([buyerEmail])
}

model OrderItem {
  id        String  @id @default(uuid())
  orderId   String
  artworkId String
  quantity  Int     @default(1)
  price     Decimal @db.Decimal(10, 2)

  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  artwork Artwork @relation(fields: [artworkId], references: [id], onDelete: Cascade)
}

model Transaction {
  id               String         @id @default(uuid())
  orderId          String?        @unique // Nullable for seller transactions
  sellerId         String?        // For seller transactions (when seller receives money)
  paymentGatewayId String?
  status           PaymentStatus @default(INITIATED)
  amount           Decimal       @db.Decimal(10, 2)
  metadata         Json?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  order            Order?         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  seller           User?          @relation("SellerTransaction", fields: [sellerId], references: [id], onDelete: Cascade)
  paymentGateway   PaymentGateway? @relation(fields: [paymentGatewayId], references: [id])
  platformEarnings PlatformEarning[]
  
  @@index([sellerId])
  @@index([orderId])
}

model Receipt {
  id        String   @id @default(uuid())
  orderId   String   @unique
  pdfUrl    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model PaymentGateway {
  id        String   @id @default(uuid())
  name      String
  enabled   Boolean  @default(true)
  config    Json?
  updatedAt DateTime @updatedAt

  transactions Transaction[]
}

model Interaction {
  id        String   @id @default(uuid())
  artworkId String
  userId    String? // User who performed the interaction (for likes, views, etc.)
  type      String
  metadata  Json?
  createdAt DateTime @default(now())

  artwork Artwork @relation(fields: [artworkId], references: [id], onDelete: Cascade)
  user    User?   @relation("Interaction_user", fields: [userId], references: [id], onDelete: Cascade)
}

model Comment {
  id         String   @id @default(uuid())
  artworkId  String
  authorName String
  content    String
  createdAt  DateTime @default(now())

  artwork Artwork @relation(fields: [artworkId], references: [id], onDelete: Cascade)
}

model Report {
  id           String           @id @default(uuid())
  targetId     String
  targetType   ReportTargetType
  reporterId   String
  reason       ReportReason
  details      String?
  status       ReportStatus     @default(OPEN)
  resolved     Boolean          @default(false)
  resolution   String?
  resolvedById String?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  // Relations
  reporter   User  @relation("Report_reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  resolvedBy User? @relation("Report_resolvedBy", fields: [resolvedById], references: [id])
}

enum ReportTargetType {
  ARTWORK
  USER
  COMMENT
  OTHER
}

enum ReportStatus {
  OPEN
  UNDER_REVIEW
  ACTIONED
  DISMISSED
}

model Policy {
  id        String   @id @default(uuid())
  type      String
  content   String
  version   String?
  updatedAt DateTime @updatedAt
}

model FeaturedContent {
  id          String   @id @default(uuid())
  label       String
  description String?
  artworkId   String?
  createdAt   DateTime @default(now())

  artwork Artwork? @relation(fields: [artworkId], references: [id])
}

model Withdrawal {
  id            String        @id @default(uuid())
  userId        String?
  payoutAccount String
  amount        Decimal       @db.Decimal(10, 2)
  status        PaymentStatus @default(INITIATED)
  payoutBatchId String? // PayPal payout batch ID for webhook matching
  metadata      Json? // Additional payout transaction details
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  user          User?         @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PlatformEarning {
  id              String      @id @default(uuid())
  orderId         String      @unique
  transactionId   String?
  amount          Decimal     @db.Decimal(10,2)
  commissionRate  Decimal     @db.Decimal(5,4)
  orderData       Json
  metadata        Json?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  order           Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  transaction     Transaction? @relation(fields: [transactionId], references: [id], onDelete: SetNull)

  @@index([orderId])
  @@index([transactionId])
  @@index([createdAt])
  @@map("platform_earnings")
}

// Blog Models
enum BlogPostStatus {
  PENDING
  APPROVED
  REJECTED
}

enum VoteType {
  LIKE
  DISLIKE
}

model BlogPost {
  id            String         @id @default(uuid())
  title         String
  slug          String         @unique
  content       String
  excerpt       String?
  featuredImage String?
  status        BlogPostStatus @default(PENDING)
  published     Boolean        @default(false)
  publishedAt   DateTime?
  authorId      String
  views         Int            @default(0)
  likes         Int            @default(0)
  dislikes      Int            @default(0)
  shares        Int            @default(0)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  editedAt      DateTime?

  author        User           @relation("BlogPost_author", fields: [authorId], references: [id], onDelete: Cascade)
  comments      BlogComment[]
  votes         BlogVote[]
  sharesList    BlogShare[]

  @@index([slug])
  @@index([status, published, publishedAt])
  @@index([authorId])
  @@index([createdAt])
  @@map("blog_posts")
}

model BlogComment {
  id          String      @id @default(uuid())
  blogPostId  String
  userId      String
  content     String
  parentId    String?
  likes       Int         @default(0)
  dislikes    Int         @default(0)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  blogPost    BlogPost    @relation(fields: [blogPostId], references: [id], onDelete: Cascade)
  user        User        @relation("BlogComment_user", fields: [userId], references: [id], onDelete: Cascade)
  parent      BlogComment? @relation("BlogComment_parent", fields: [parentId], references: [id], onDelete: Cascade)
  replies     BlogComment[] @relation("BlogComment_parent")

  @@index([blogPostId])
  @@index([userId])
  @@index([parentId])
  @@map("blog_comments")
}

model BlogVote {
  id          String      @id @default(uuid())
  blogPostId  String
  userId      String
  type        VoteType
  createdAt   DateTime    @default(now())

  blogPost    BlogPost    @relation(fields: [blogPostId], references: [id], onDelete: Cascade)
  user        User        @relation("BlogVote_user", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([blogPostId, userId])
  @@index([blogPostId])
  @@index([userId])
  @@map("blog_votes")
}

model BlogShare {
  id          String      @id @default(uuid())
  blogPostId  String
  userId      String?
  platform    String?
  createdAt   DateTime    @default(now())

  blogPost    BlogPost    @relation(fields: [blogPostId], references: [id], onDelete: Cascade)
  user        User?       @relation("BlogShare_user", fields: [userId], references: [id], onDelete: Cascade)

  @@index([blogPostId])
  @@index([userId])
  @@map("blog_shares")
}



enum PAYMENT_STATUS {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum NOTIFICATION_TYPE {
  INFO
  WARNING
  ALERT
  MESSAGE
  SYSTEM
}

enum ArtworkStatus {
  PENDING
  APPROVED
  REJECTED
  SOLD
  WITHDRAWN
}

enum DISPUTE_STATUS {
  IN_PROGRESS
  RESOLVED
  CLOSED
  REJECTED
}

enum OrderStatus {
  PENDING
  PAID
  CANCELLED
  REFUNDED
}

model Settings {
  id        String   @id @default(uuid())
  key       String   @unique
  value     Json
  category  String   @default("platform") // platform, payment, order, collection
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  @@map("settings")
}

enum PaymentStatus {
  INITIATED
  PROCESSING
  COMPLETED
  FAILED
  REJECTED
  REFUNDED
}

enum ReportReason {
  SPAM
  COPYRIGHT
  ABUSE
  INAPPROPRIATE
  OTHER
}

enum CHAT_STATUS {
  OPEN
  CLOSED
  ARCHIVED
}

enum MESSAGE_TYPE {
  TEXT
  IMAGE
  VIDEO
  SYSTEM
}

enum MESSAGE_STATUS {
  SENT
  DELIVERED
  READ
  PENDING
  APPROVED
  REJECTED
  SOLD
  WITHDRAWN
}

model TalentType {
  id          String   @id @default(uuid())
  name        String   @unique
  slug        String   @unique
  description String?
  image       String?  // S3 URL or object key
  isActive    Boolean  @default(true)
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users       UserOnTalentType[]

  @@map("talent_types")
}

model UserOnTalentType {
  id           String     @id @default(uuid())
  userId       String
  talentTypeId String
  createdAt    DateTime   @default(now())

  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  talentType   TalentType @relation(fields: [talentTypeId], references: [id], onDelete: Cascade)

  @@unique([userId, talentTypeId])
  @@map("user_on_talent_types")
}

